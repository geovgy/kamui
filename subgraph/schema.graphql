type EIP712DomainChanged @entity(immutable: true) {
  id: Bytes!

  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type OwnershipTransferred @entity(immutable: true) {
  id: Bytes!
  previousOwner: Bytes! # address
  newOwner: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type WormholeAsset @entity(immutable: false) {
  id: Bytes! # asset address
  asset: Bytes! # address
  implementation: WormholeAssetImplementation!
  initData: Bytes! # bytes
  unshields: [Withdrawal!]! @derivedFrom(field: "asset")
  totalUnshielded: BigInt! # uint256
  createdAt: BigInt!
  startBlock: BigInt!
}

type WormholeAssetImplementation @entity(immutable: false) {
  id: Bytes! # implementation address
  address: Bytes! # address
  isApproved: Boolean! # bool
  wormholeAssets: [WormholeAsset!]! @derivedFrom(field: "implementation")
  createdAt: BigInt! # uint256
  updatedAt: BigInt! # uint256
}

type Ragequit @entity(immutable: true) {
  id: Bytes!
  entryId: BigInt! # uint256
  quitter: Bytes! # address
  returnedTo: Bytes! # address
  asset: Bytes! # address
  asset_id: BigInt! # uint256
  amount: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type ShieldedTree @entity(immutable: false) {
  id: Bytes! # treeId
  leaves: [BigInt!]! # uint256[]
  size: BigInt! # uint256
  createdAt: BigInt! # uint256
  updatedAt: BigInt! # uint256
}

type WormholeTree @entity(immutable: false) {
  id: Bytes! # treeId
  leaves: [BigInt!]! # uint256[]
  commitments: [WormholeCommitment!]! # WormholeCommitment[]
  size: BigInt! # uint256
  createdAt: BigInt! # uint256
  updatedAt: BigInt! # uint256
}

type ShieldedTransfer @entity(immutable: true) {
  id: Bytes!
  treeId: BigInt! # uint256
  startIndex: BigInt! # uint256
  commitments: [BigInt!]! # uint256[]
  nullifiers: [ShieldNullifier!]! # ShieldNullifier[]
  withdrawals: [Withdrawal!]! # Withdrawal[]
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Withdrawal @entity(immutable: true) {
  id: ID! # shieldedTransfer id:withdrawalIndex
  to: Bytes! # address
  asset: WormholeAsset! # WormholeAsset
  asset_id: BigInt! # uint256
  amount: BigInt! # uint256
  shieldedTransfer: ShieldedTransfer! @derivedFrom(field: "withdrawals") # ShieldedTransfer
}

type ShieldNullifier @entity(immutable: true) {
  id: Bytes! # nullifier
  nullifier: Bytes! # bytes32
  shieldedTransfer: ShieldedTransfer! @derivedFrom(field: "nullifiers") # ShieldedTransfer
}

type VerifierAdded @entity(immutable: true) {
  id: Bytes!
  verifier: Bytes! # address
  inputs: BigInt! # uint256
  outputs: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type WormholeApprover @entity(immutable: false) {
  id: Bytes! # address
  address: Bytes! # address
  isApprover: Boolean! # bool
  createdAt: BigInt! # uint256
  updatedAt: BigInt! # uint256
}

type WormholeCommitment @entity(immutable: true) {
  id: ID! # treeId:leafIndex
  entry: WormholeEntry! # WormholeEntry
  commitment: BigInt! # uint256
  treeId: BigInt! # uint256
  leafIndex: BigInt! # uint256
  assetId: Bytes! # bytes32
  from: Bytes! # address
  to: Bytes! # address
  amount: BigInt! # uint256
  approved: Boolean! # bool
  submittedBy: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type WormholeEntry @entity(immutable: true) {
  id: Bytes! # entryId
  entryId: BigInt! # uint256
  token: Bytes! # address
  from: Bytes! # address
  to: Bytes! # address
  tokenId: BigInt! # uint256
  amount: BigInt! # uint256
  commitment: WormholeCommitment @derivedFrom(field: "entry") # if undefined, the entry is not appended to the wormhole tree yet
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type WormholeNullifier @entity(immutable: true) {
  id: Bytes! # nullifier
  nullifier: Bytes! # bytes32
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}
